# **执行 select ... for update 语句，如果查询条件没有索引字段的话，是加「行锁」还是加「表锁」？**

1. 普通的select查询语句不会加行级锁，因为它通过**MVCC实现了无锁查询**

   但是，它**会加表级锁**（元数据锁，MDL锁，是server层实现的表级锁）。对表DML（增删改查）操作加MDL读锁，对表DDL（表结构变更）操作加DML写锁。**为了保证表元数据一致性**。

2. select ... for update 会加什么锁？

锁定读语句，会对表记录加x型行级锁

在**读已提交隔离级别**下，行级锁的种类只有记录锁，也就是仅仅把一条记录锁上。

在**可重复读隔离级别**下，行级锁的种类除了有记录锁，还有间隙锁（目的是为了**避免幻读**），所以行级锁的种类主要有三类：

- Record Lock，记录锁，也就是仅仅把一条记录锁上；
- Gap Lock，间隙锁，锁定一个范围，但是不包含记录本身；
- Next-Key Lock：Record Lock + Gap Lock 的组合，锁定一个范围，并且锁定记录本身。

在**能使用记录锁或者间隙锁就能避免幻读现象的场景**下， <u>next-key lock 就会退化成记录锁或间隙锁</u>。

3. 执行 select ... for update 语句，如果查询条件没有索引字段的话，会加什么锁？

   整张表都无法进行增删改了，从这个现象看，好像是把表锁起来了，**但是并不是因为上面这两个表级锁的原因**。

   而是**因为如果锁定读查询语句，没有使用索引列作为查询条件，导致扫描是全表扫描。那么，每一条记录的索引上都会加 next-key 锁（行级锁），这样就相当于锁住的全表，这时如果其他事务对该表进行增、删、改操作的时候，都会被阻塞**。