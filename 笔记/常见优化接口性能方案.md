1)数据库慢SQL

．通过explain执行计划分析下

．锁表(先把锁表的慢SQL kill一波)．

．未加索引

．加了索引，索引失效(对索引加方法转换、区分度很低比如枚举值、索引列大量空值)

．小表驱动大表(尽可能过滤数据)

．SQL太复杂(join超过3张表或者子查询比较多，建议拆分SQL为多个接口，比如先从某个主接口查某个表数据，然后关联字段作为条件从另外一个表查询，进行内存拼接)

．返回的数据量数据量太大(可以分页多批次查询，可以非c端可以考虑多线程查询)

．单表数据量太大（考虑放分片库或分表或者clickhouse、es存储)

 

2)调用第三方接口慢

．调用第三方设置合理的超时时间，比如你的接口是高并发接口，从自身对方接口的要求和对方线上P95接口的平均rt，综合设置超时时间．

．集成sentinel或hystrix限流熔断框架，防止对方接口拖垮我们自己的接口

．事务型操作根据实际的情况酌情决定是否重试补偿(本地消息表+job重试)，比如新增、修改等操作要考虑对方接口是否支持幂等，防止超发

．循环调用，改为单次批量调用，减少IO损耗(比如调用AB接口，根据用户ID、分组ID多个，for调用改为一次传多个分组ID)

．缓存查询结果(比如根据用户ID查询用户信息)

 

3)中间件慢

． redis慢（是否有热key、大key，热key:上本地缓存，大key:拆分大key或者采用set结构的sismember等方法判断-0(1)时间复杂度)

．kafka(mq)慢（生产端慢:向kafka丢消息慢了，可以使用阻塞队列接收，批量丢消息等优化消费端:扩分区、增加消费节点、增加消费线程或批量消费批量写库)

 

4)程序逻辑慢

．非法校验逻辑前置，避免无用数据穿透消耗系统资源，减少无效调用

．循环调用改为单次调用（比如查数据库或查其他rpc或restful接口，能批量调用尽量批量调用，数据在内存组装处理)

．同步调用改为异步调用（采用completableFuture异步非阻塞，并行调用不同的rpc接口)

．非核心逻辑剥离(拆分大事务，采用mq异步解耦)

．线程池合理设置(千万不要创建无界队列线程池，线程池满了以后要重写拒绝策略，考虑告警加数据持久化)

．锁合理设置（本地读写锁设计不合理或锁力度太大、分布式锁合理使用防止热点key)

．优化gc参数（考虑young gc、full gc是否太频繁、调整gc算法、新生代老年代比例)

．只打印必要日志(warn或error级别)

 

5)架构优化

．高并发读逻辑都走redis，尽可能不穿透到db

．涉及写逻辑数据〔异步、批量处理、分库分表)

．接口接入限流熔断兜底(sentinel或hystrix)

．监控告警(error日志告警、接口慢查询或不可用或限流熔断告警、DB告警、中间件告警、应用系统告警)

．接口加动态配置开关快速切断流量或降级某一些非核心服务调用

．设计自动对账job，保证数据自动可修复